name: Production KittenTTS FastAPI with Advanced Caching

on:
  workflow_dispatch:
  repository_dispatch:
    types: [restart-tts]
  push:

env:
  PYTHON_VERSION: "3.10"
  NODE_VERSION: "18"
  CACHE_VERSION: "v2"
  PIP_CACHE_DIR: /tmp/.pip-cache
  MODEL_CACHE_DIR: /tmp/.model-cache
  SYSTEM_CACHE_DIR: /tmp/.system-cache

jobs:
  serve:
    runs-on: ubuntu-latest
    timeout-minutes: 1440  # 24 hours max timeout
    
    steps:
      - name: üìã Show Machine Specifications
        run: |
          echo "üñ•Ô∏è ===== MACHINE SPECIFICATIONS ====="
          echo "CPU Information:"
          lscpu | head -20
          echo ""
          echo "Memory Information:"
          free -h
          echo ""
          echo "Disk Information:"
          df -h
          echo ""
          echo "Operating System:"
          uname -a
          cat /etc/os-release | head -5
          echo ""
          echo "Available Python versions:"
          ls /usr/bin/python* 2>/dev/null || echo "None found"
          echo ""
          echo "Network Information:"
          ip addr show | grep inet | head -5
          echo ""
          echo "Environment Variables:"
          env | grep -E "(GITHUB|RUNNER)" | head -10
          echo "üñ•Ô∏è ===== END SPECIFICATIONS ====="
          
      - name: üì¶ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: üíæ Cache System Dependencies
        uses: actions/cache@v4
        id: cache-system
        with:
          path: |
            ${{ env.SYSTEM_CACHE_DIR }}
            /usr/local/lib/python${{ env.PYTHON_VERSION }}/site-packages
            ~/.cache/pip
          key: system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', '**/setup.py') }}
          restore-keys: |
            system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.PYTHON_VERSION }}-
            system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-
            system-deps-
            
      - name: üêç Setup Python with Caching
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: |
            **/requirements.txt
            **/setup.py
            
      - name: üíæ Cache ML Models & KittenTTS
        uses: actions/cache@v4
        id: cache-models
        with:
          path: |
            ${{ env.MODEL_CACHE_DIR }}
            ~/.cache/huggingface
            ~/.cache/torch
            ~/.local/share/kittentts
            ~/kittentts_models
          key: models-${{ env.CACHE_VERSION }}-kittentts-v0.1.0-${{ runner.os }}
          restore-keys: |
            models-${{ env.CACHE_VERSION }}-kittentts-
            models-${{ env.CACHE_VERSION }}-
            models-
            
      - name: üíæ Cache Node.js for Monitoring Tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            /usr/local/lib/node_modules
          key: node-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.NODE_VERSION }}
          restore-keys: |
            node-${{ env.CACHE_VERSION }}-${{ runner.os }}-
            node-${{ env.CACHE_VERSION }}-
            
      - name: üîß Install System Dependencies with Retry Logic
        run: |
          echo "üîß Installing system dependencies with caching..."
          
          # Create cache directories
          mkdir -p "${{ env.PIP_CACHE_DIR }}"
          mkdir -p "${{ env.MODEL_CACHE_DIR }}"
          mkdir -p "${{ env.SYSTEM_CACHE_DIR }}"
          
          # Function for retry logic
          retry_command() {
            local cmd="$1"
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• All attempts failed"
                  return 1
                fi
                sleep $((attempt * 2))
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Update package lists with retry
          retry_command "sudo apt-get update -qq"
          
          # Install system packages
          echo "Installing system audio libraries..."
          retry_command "sudo apt-get install -y -qq \
            ffmpeg \
            libsndfile1-dev \
            libasound2-dev \
            portaudio19-dev \
            libportaudio2 \
            libportaudiocpp0 \
            python3-dev \
            build-essential \
            curl \
            wget \
            htop \
            iotop \
            nethogs \
            sysstat"
            
          echo "‚úÖ System dependencies installed successfully"

      - name: üêç Install Python Dependencies with Bulletproof Error Handling
        run: |
          echo "üêç Installing Python dependencies with robust error handling..."
          
          # Define retry function with better error handling
          retry_command() {
            local cmd="$1"
            local description="$2"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üì¶ $description (attempt $attempt/$max_attempts)"
              
              if eval "$cmd"; then
                echo "‚úÖ $description succeeded"
                return 0
              else
                local exit_code=$?
                echo "‚ùå $description failed with exit code $exit_code"
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• All attempts failed for: $description"
                  return $exit_code
                fi
                
                echo "‚è≥ Waiting before retry..."
                sleep $((attempt * 3))
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Upgrade pip and essential tools first
          echo "üîß Upgrading pip and build tools..."
          retry_command "python -m pip install --upgrade pip setuptools wheel --cache-dir='${{ env.PIP_CACHE_DIR }}'" "pip upgrade"
          
          # Create corrected requirements.txt with proper PyTorch syntax
          echo "üìù Creating corrected requirements.txt..."
          cat > requirements_fixed.txt << 'EOF'
          # Core FastAPI dependencies (pinned for stability)
          fastapi==0.104.1
          uvicorn[standard]==0.24.0
          pydantic==2.5.0
          
          # Audio processing essentials
          soundfile==0.12.1
          numpy==1.24.4
          scipy==1.11.4
          
          # Optional audio libraries (installed separately)
          # librosa==0.10.1
          # pydub==0.25.1
          
          # Core ML dependencies (without local version specifiers)
          transformers==4.35.2
          tokenizers==0.15.0
          huggingface-hub==0.19.4
          
          # System monitoring
          psutil==5.9.6
          
          # HTTP & networking
          httpx==0.25.2
          aiofiles==23.2.1
          python-multipart==0.0.6
          
          # Utilities
          python-dotenv==1.0.0
          typing-extensions==4.8.0
          EOF
          
          # Install core dependencies first (most stable)
          echo "üéØ Installing core FastAPI dependencies..."
          retry_command "pip install fastapi==0.104.1 'uvicorn[standard]==0.24.0' pydantic==2.5.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Core FastAPI packages"
          
          # Install system dependencies
          echo "‚öôÔ∏è Installing system dependencies..."
          retry_command "pip install psutil==5.9.6 aiofiles==23.2.1 python-multipart==0.0.6 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "System packages"
          
          # Install audio processing (essential)
          echo "üéµ Installing audio processing dependencies..."
          retry_command "pip install soundfile==0.12.1 numpy==1.24.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Audio essentials"
          
          # Install PyTorch CPU version (separate command to handle special index)
          echo "üî• Installing PyTorch CPU version..."
          retry_command "pip install torch==2.1.0+cpu torchaudio==2.1.0+cpu --index-url https://download.pytorch.org/whl/cpu --cache-dir='${{ env.PIP_CACHE_DIR }}'" "PyTorch CPU"
          
          # Fallback PyTorch installation if CPU version fails
          if ! python -c "import torch" 2>/dev/null; then
            echo "‚ö†Ô∏è CPU PyTorch failed, installing regular PyTorch..."
            retry_command "pip install torch==2.1.0 torchaudio==2.1.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "PyTorch regular"
          fi
          
          # Install Hugging Face dependencies
          echo "ü§ó Installing Hugging Face dependencies..."
          retry_command "pip install transformers==4.35.2 tokenizers==0.15.0 huggingface-hub==0.19.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Hugging Face"
          
          # Install remaining utilities
          echo "üîß Installing utility packages..."
          retry_command "pip install httpx==0.25.2 python-dotenv==1.0.0 typing-extensions==4.8.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Utilities"
          
          # Install optional audio libraries (non-critical)
          echo "üéº Installing optional audio libraries..."
          
          # Try scipy first
          if ! retry_command "pip install scipy==1.11.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "SciPy"; then
            echo "‚ö†Ô∏è SciPy installation failed, trying older version..."
            retry_command "pip install scipy==1.10.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "SciPy fallback" || echo "‚ö†Ô∏è SciPy installation failed, continuing without it"
          fi
          
          # Try librosa (often problematic)
          if ! retry_command "pip install librosa==0.10.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Librosa"; then
            echo "‚ö†Ô∏è Librosa installation failed, installing minimal audio processing..."
            retry_command "pip install librosa --no-deps --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Librosa no-deps" || echo "‚ö†Ô∏è Continuing without librosa"
          fi
          
          # Try pydub (usually works)
          retry_command "pip install pydub==0.25.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Pydub" || echo "‚ö†Ô∏è Continuing without pydub"
          
          # Comprehensive verification
          echo "üîç Verifying critical installations..."
          
          python3 -c "
          import sys
          
          critical_packages = [
              ('fastapi', 'FastAPI'),
              ('uvicorn', 'Uvicorn'),
              ('pydantic', 'Pydantic'),
              ('soundfile', 'SoundFile'),
              ('numpy', 'NumPy'),
              ('psutil', 'PSUtil'),
              ('aiofiles', 'AIOFiles')
          ]
          
          optional_packages = [
              ('torch', 'PyTorch'),
              ('transformers', 'Transformers'),
              ('huggingface_hub', 'Hugging Face Hub'),
              ('scipy', 'SciPy'),
              ('librosa', 'Librosa'),
              ('pydub', 'Pydub')
          ]
          
          print('=== CRITICAL PACKAGE VERIFICATION ===')
          critical_failed = []
          
          for module, name in critical_packages:
              try:
                  __import__(module)
                  print(f'‚úÖ {name}: OK')
              except ImportError as e:
                  print(f'‚ùå {name}: FAILED - {e}')
                  critical_failed.append(name)
          
          print('\\n=== OPTIONAL PACKAGE VERIFICATION ===')
          for module, name in optional_packages:
              try:
                  __import__(module)
                  print(f'‚úÖ {name}: OK')
              except ImportError as e:
                  print(f'‚ö†Ô∏è {name}: Not available - {e}')
          
          if critical_failed:
              print(f'\\n‚ùå CRITICAL FAILURE: Missing packages: {critical_failed}')
              print('The FastAPI server may not work properly.')
              sys.exit(1)
          else:
              print('\\n‚úÖ All critical packages verified successfully!')
              print('FastAPI server should work correctly.')
          "
          
          # Final installation summary
          echo "üìä Installation Summary:"
          pip list | grep -E "(fastapi|uvicorn|pydantic|torch|transformers|soundfile|numpy)" || echo "No matching packages found"
          
          echo "‚úÖ Python dependencies installation completed"
        
      - name: üê± Install KittenTTS with Caching & Error Handling
        run: |
          echo "üê± Installing KittenTTS..."
          
          # Set up model cache environment
          export HF_HOME="${{ env.MODEL_CACHE_DIR }}/huggingface"
          export TRANSFORMERS_CACHE="${{ env.MODEL_CACHE_DIR }}/transformers"
          export HF_HUB_CACHE="${{ env.MODEL_CACHE_DIR }}/hub"
          
          mkdir -p "$HF_HOME" "$TRANSFORMERS_CACHE" "$HF_HUB_CACHE"
          
          # Function to install KittenTTS with multiple methods
          install_kittentts() {
            echo "Method 1: Installing from PyPI..."
            if pip install kittentts --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from PyPI"
              return 0
            fi
            
            echo "Method 2: Installing from GitHub release..."
            if pip install https://github.com/KittenML/KittenTTS/releases/download/0.1/kittentts-0.1.0-py3-none-any.whl --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from GitHub"
              return 0
            fi
            
            echo "Method 3: Installing from source..."
            if pip install git+https://github.com/KittenML/KittenTTS.git --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from source"
              return 0
            fi
            
            echo "‚ùå All KittenTTS installation methods failed"
            return 1
          }
          
          # Try to install KittenTTS
          if ! install_kittentts; then
            echo "‚ö†Ô∏è KittenTTS installation failed, but continuing..."
            echo "Will attempt runtime installation in the API"
          fi
          
          # Pre-download models if possible
          echo "üì• Pre-downloading KittenTTS models..."
          python3 -c "
          try:
              from huggingface_hub import snapshot_download
              import os
              
              cache_dir = '${{ env.MODEL_CACHE_DIR }}/huggingface'
              os.makedirs(cache_dir, exist_ok=True)
              
              print('Downloading KittenTTS nano model...')
              snapshot_download(
                  repo_id='KittenML/kitten-tts-nano-0.1',
                  cache_dir=cache_dir,
                  resume_download=True,
                  local_files_only=False
              )
              print('‚úÖ Model downloaded successfully')
              
          except Exception as e:
              print(f'‚ö†Ô∏è Model pre-download failed: {e}')
              print('Models will be downloaded at runtime')
          " || echo "‚ö†Ô∏è Model pre-download skipped"
          
          echo "‚úÖ KittenTTS setup completed"
          
      - name: üîß Setup Monitoring Tools
        run: |
          echo "üîß Setting up monitoring tools..."
          
          # Install system monitoring tools
          sudo apt-get install -y -qq htop iotop nethogs sysstat lsof
          
          # Create monitoring script
          cat > monitor.sh << 'EOF'
          #!/bin/bash
          
          show_system_stats() {
            echo "üìä ===== SYSTEM MONITORING $(date) ====="
            
            # CPU Usage
            echo "üî• CPU Usage:"
            top -bn1 | grep "Cpu(s)" | head -1
            
            # Memory Usage
            echo "üíæ Memory Usage:"
            free -h | head -2
            
            # Disk Usage
            echo "üíø Disk Usage:"
            df -h / | tail -1
            
            # Network Stats
            echo "üåê Network:"
            ss -tuln | grep :8000 || echo "Port 8000: Not listening"
            
            # Process Stats
            echo "‚öôÔ∏è Top Processes (CPU):"
            ps aux --sort=-%cpu | head -6
            
            # Load Average
            echo "üìà Load Average:"
            uptime
            
            # Temperature (if available)
            if command -v sensors &> /dev/null; then
              echo "üå°Ô∏è Temperature:"
              sensors | grep -E "(Core|temp)" | head -3 || echo "No temperature sensors found"
            fi
            
            echo "üìä ===== END MONITORING ====="
            echo ""
          }
          
          # Export function for use
          export -f show_system_stats
          EOF
          
          chmod +x monitor.sh
          source monitor.sh
          
          echo "‚úÖ Monitoring tools ready"
          
      - name: üöÄ Start Production FastAPI Server
        run: |
          echo "üöÄ Starting production FastAPI server..."
          source monitor.sh
          
          # Show initial system stats
          show_system_stats
          
          # Start FastAPI server with enhanced logging
          echo "Starting FastAPI with production configuration..."
          nohup uvicorn main:app \
            --host 0.0.0.0 \
            --port 8000 \
            --log-level info \
            --access-log \
            --workers 1 \
            --loop asyncio \
            --http h11 \
            --ws websockets > fastapi.log 2>&1 &
          
          FASTAPI_PID=$!
          echo "FastAPI PID: $FASTAPI_PID"
          echo "$FASTAPI_PID" > fastapi.pid
          
          # Enhanced server startup verification
          echo "‚è≥ Waiting for FastAPI to initialize..."
          startup_timeout=180  # 3 minutes
          startup_time=0
          
          while [ $startup_time -lt $startup_timeout ]; do
            if curl -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ FastAPI server is responding!"
              
              # Get detailed health check
              health_response=$(curl -s http://localhost:8000/health)
              echo "Health Status: $health_response"
              break
            fi
            
            echo "‚è≥ Startup progress ($startup_time/${startup_timeout}s)..."
            
            # Show logs if startup is taking long
            if [ $startup_time -gt 60 ] && [ $((startup_time % 30)) -eq 0 ]; then
              echo "üìã Recent FastAPI logs:"
              tail -10 fastapi.log || echo "No logs yet"
            fi
            
            sleep 5
            startup_time=$((startup_time + 5))
          done
          
          # Final startup check
          if ! curl -s http://localhost:8000/health > /dev/null 2>&1; then
            echo "‚ùå FastAPI failed to start within timeout. Full logs:"
            cat fastapi.log
            show_system_stats
            exit 1
          fi
          
          echo "‚úÖ FastAPI server started successfully"
          
      - name: üåê Setup Cloudflare Tunnel with No Timeout
        run: |
          echo "üåê Setting up Cloudflare tunnel (no timeout limits)..."
          
          # Download cloudflared with caching
          CLOUDFLARED_CACHE="/tmp/cloudflared"
          if [ ! -f "$CLOUDFLARED_CACHE" ]; then
            echo "üì• Downloading cloudflared..."
            curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o "$CLOUDFLARED_CACHE"
            chmod +x "$CLOUDFLARED_CACHE"
          else
            echo "üìã Using cached cloudflared"
          fi
          
          cp "$CLOUDFLARED_CACHE" ./cloudflared
          chmod +x ./cloudflared
          
          # Enhanced tunnel startup with unlimited timeout
          echo "üöÄ Starting Cloudflare tunnel..."
          nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
          TUNNEL_PID=$!
          echo "Tunnel PID: $TUNNEL_PID"
          echo "$TUNNEL_PID" > tunnel.pid
          
          # Wait for tunnel with no time limit but with progress updates
          echo "‚è≥ Waiting for tunnel to establish (no timeout)..."
          tunnel_attempts=0
          
          while true; do
            tunnel_attempts=$((tunnel_attempts + 1))
            
            # Check for tunnel URL in logs
            if grep -q "https://.*trycloudflare.com" tunnel.log 2>/dev/null; then
              URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | head -n1)
              echo "üåê Tunnel established at: $URL"
              break
            fi
            
            # Progress reporting every 30 seconds
            if [ $((tunnel_attempts % 6)) -eq 0 ]; then
              echo "‚è≥ Tunnel attempt $tunnel_attempts (${tunnel_attempts}0s elapsed)..."
              
              # Show recent tunnel logs
              echo "üìã Recent tunnel logs:"
              tail -5 tunnel.log 2>/dev/null || echo "No tunnel logs yet"
              
              # Check if tunnel process is still running
              if ! kill -0 $TUNNEL_PID 2>/dev/null; then
                echo "‚ùå Tunnel process died, restarting..."
                nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
                TUNNEL_PID=$!
                echo "$TUNNEL_PID" > tunnel.pid
              fi
            fi
            
            sleep 5
          done
          
          # Extract and validate URL
          URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | head -n1 2>/dev/null)
          
          if [ -z "$URL" ]; then
            echo "‚ùå Failed to extract tunnel URL. Full tunnel log:"
            cat tunnel.log
            exit 1
          fi
          
          echo "üåê Tunnel URL: $URL"
          
          # Comprehensive tunnel testing
          echo "üß™ Testing tunnel connectivity..."
          test_attempts=0
          max_test_attempts=20
          
          while [ $test_attempts -lt $max_test_attempts ]; do
            if curl -s --max-time 30 "$URL/health" > /dev/null; then
              echo "‚úÖ Tunnel is working correctly!"
              
              # Test TTS endpoint
              if curl -s --max-time 10 "$URL/" > /dev/null; then
                echo "‚úÖ TTS API accessible through tunnel"
              fi
              break
            fi
            
            test_attempts=$((test_attempts + 1))
            echo "üîÑ Tunnel test attempt $test_attempts/$max_test_attempts..."
            sleep 3
          done
          
          if [ $test_attempts -eq $max_test_attempts ]; then
            echo "‚ö†Ô∏è Tunnel connectivity tests failed, but continuing..."
          fi
          
          # Enhanced webhook notification with retry
          echo "üì° Sending webhook notification..."
          webhook_payload=$(cat << EOF
          {
            "url": "$URL",
            "status": "running",
            "service": "KittenTTS Production API",
            "version": "2.0.0",
            "timestamp": "$(date -Iseconds)",
            "features": [
              "Real KittenTTS",
              "Long text support",
              "Caching enabled",
              "Robust error handling",
              "System monitoring"
            ]
          }
          EOF
          )
          
          # Try webhook with retries
          for i in {1..3}; do
            if curl -X POST "https://n8n-nightly-liyp.onrender.com/webhook/b24ea92e-9123-4cb1-8a79-9a08ae45c536" \
              -H "Content-Type: application/json" \
              -d "$webhook_payload" \
              --max-time 30; then
              echo "‚úÖ Webhook notification sent successfully"
              break
            else
              echo "‚ö†Ô∏è Webhook attempt $i failed, retrying..."
              sleep 5
            fi
          done
          
          # Save important information
          echo "üìù Saving service information..."
          cat > service_info.json << EOF
          {
            "tunnel_url": "$URL",
            "fastapi_pid": $FASTAPI_PID,
            "tunnel_pid": $TUNNEL_PID,
            "start_time": "$(date -Iseconds)",
            "endpoints": {
              "health": "$URL/health",
              "tts": "$URL/tts",
              "voices": "$URL/voices",
              "metrics": "$URL/metrics",
              "docs": "$URL/docs"
            }
          }
          EOF
          
          echo "‚úÖ Cloudflare tunnel setup completed"
          
      - name: üîÑ Production Keep-Alive with Advanced Monitoring
        run: |
          echo "üîÑ Starting production keep-alive with comprehensive monitoring..."
          source monitor.sh
          
          # Load service info
          if [ -f service_info.json ]; then
            URL=$(python3 -c "import json; print(json.load(open('service_info.json'))['tunnel_url'])")
            echo "üåê Service URL: $URL"
          else
            URL="https://unknown.trycloudflare.com"
          fi
          
          # Enhanced monitoring function
          monitor_services() {
            local cycle=$1
            echo "üîç ===== MONITORING CYCLE $cycle ====="
            
            # System statistics
            show_system_stats
            
            # Service health checks
            echo "üè• SERVICE HEALTH CHECKS:"
            
            # FastAPI health
            if curl -s --max-time 10 http://localhost:8000/health > /dev/null; then
              echo "‚úÖ FastAPI: Healthy"
              
              # Get metrics
              metrics=$(curl -s --max-time 10 http://localhost:8000/metrics 2>/dev/null || echo '{"error": "metrics unavailable"}')
              echo "üìä Metrics: $metrics"
            else
              echo "‚ùå FastAPI: Not responding"
            fi
            
            # Tunnel health
            if curl -s --max-time 10 "$URL/health" > /dev/null; then
              echo "‚úÖ Tunnel: Healthy"
            else
              echo "‚ùå Tunnel: Not responding"
            fi
            
            # Process status
            echo "‚öôÔ∏è PROCESS STATUS:"
            if [ -f fastapi.pid ] && kill -0 $(cat fastapi.pid) 2>/dev/null; then
              echo "‚úÖ FastAPI process: Running (PID: $(cat fastapi.pid))"
            else
              echo "‚ùå FastAPI process: Not running"
            fi
            
            if [ -f tunnel.pid ] && kill -0 $(cat tunnel.pid) 2>/dev/null; then
              echo "‚úÖ Tunnel process: Running (PID: $(cat tunnel.pid))"
            else
              echo "‚ùå Tunnel process: Not running"
            fi
            
            # Disk usage
            echo "üíø DISK USAGE:"
            du -sh audio_files/ 2>/dev/null || echo "Audio files: 0B"
            du -sh cache/ 2>/dev/null || echo "Cache: 0B"
            
            # Network connections
            echo "üåê NETWORK CONNECTIONS:"
            ss -tuln | grep :8000 || echo "Port 8000: Not listening"
            
            echo "üîç ===== END CYCLE $cycle ====="
            echo ""
          }
          
          # Enhanced service recovery
          recover_fastapi() {
            echo "üîß Attempting FastAPI recovery..."
            
            # Kill existing process
            if [ -f fastapi.pid ]; then
              kill $(cat fastapi.pid) 2>/dev/null || true
              sleep 5
            fi
            pkill -f uvicorn || true
            sleep 2
            
            # Clean up and restart
            cleanup_memory() {
              python3 -c "import gc; gc.collect()" 2>/dev/null || true
            }
            cleanup_memory
            
            # Restart FastAPI
            echo "üîÑ Restarting FastAPI..."
            nohup uvicorn main:app \
              --host 0.0.0.0 \
              --port 8000 \
              --log-level info \
              --access-log \
              --workers 1 > fastapi.log 2>&1 &
            
            NEW_PID=$!
            echo "$NEW_PID" > fastapi.pid
            echo "‚úÖ FastAPI restarted with PID: $NEW_PID"
            
            # Wait for recovery
            sleep 10
          }
          
          recover_tunnel() {
            echo "üîß Attempting tunnel recovery..."
            
            # Kill existing tunnel
            if [ -f tunnel.pid ]; then
              kill $(cat tunnel.pid) 2>/dev/null || true
              sleep 5
            fi
            pkill -f cloudflared || true
            sleep 2
            
            # Restart tunnel
            echo "üîÑ Restarting tunnel..."
            nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
            NEW_TUNNEL_PID=$!
            echo "$NEW_TUNNEL_PID" > tunnel.pid
            
            # Wait for new URL
            sleep 15
            NEW_URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | tail -n1 2>/dev/null)
            if [ -n "$NEW_URL" ]; then
              URL="$NEW_URL"
              echo "‚úÖ Tunnel recovered with new URL: $URL"
              
              # Update service info
              python3 -c "
          import json
          try:
              with open('service_info.json', 'r') as f:
                  data = json.load(f)
              data['tunnel_url'] = '$NEW_URL'
              data['tunnel_pid'] = $NEW_TUNNEL_PID
              with open('service_info.json', 'w') as f:
                  json.dump(data, f, indent=2)
          except Exception as e:
              print(f'Failed to update service info: {e}')
              "
            else
              echo "‚ùå Tunnel recovery failed"
            fi
          }
          
          # Main monitoring loop - UNLIMITED TIME
          echo "üîÑ Starting unlimited monitoring loop..."
          cycle=0
          last_health_check=0
          consecutive_failures=0
          max_consecutive_failures=5
          
          while true; do
            cycle=$((cycle + 1))
            current_time=$(date +%s)
            
            # Show monitoring every 2 minutes
            if [ $((current_time - last_health_check)) -ge 120 ]; then
              monitor_services $cycle
              last_health_check=$current_time
            fi
            
            # Health checks and recovery every 30 seconds
            fastapi_healthy=false
            tunnel_healthy=false
            
            # Check FastAPI
            if curl -s --max-time 15 http://localhost:8000/health > /dev/null; then
              fastapi_healthy=true
              consecutive_failures=0
            else
              echo "‚ö†Ô∏è FastAPI health check failed"
              consecutive_failures=$((consecutive_failures + 1))
            fi
            
            # Check tunnel
            if curl -s --max-time 15 "$URL/health" > /dev/null; then
              tunnel_healthy=true
            else
              echo "‚ö†Ô∏è Tunnel health check failed"
            fi
            
            # Recovery logic
            if [ "$fastapi_healthy" = false ] && [ $consecutive_failures -ge 3 ]; then
              echo "üö® FastAPI requires recovery (failures: $consecutive_failures)"
              recover_fastapi
              consecutive_failures=0
            fi
            
            if [ "$tunnel_healthy" = false ] && [ "$fastapi_healthy" = true ]; then
              echo "üö® Tunnel requires recovery"
              recover_tunnel
            fi
            
            # Memory management
            if [ $((cycle % 50)) -eq 0 ]; then  # Every ~25 minutes
              echo "üßπ Performing periodic maintenance..."
              
              # Force garbage collection via API
              curl -s --max-time 10 http://localhost:8000/cleanup > /dev/null || true
              
              # System cleanup
              python3 -c "import gc; gc.collect()" 2>/dev/null || true
              
              echo "‚úÖ Maintenance completed"
            fi
            
            # Status update every 10 minutes
            if [ $((cycle % 120)) -eq 0 ]; then
              echo "üì° Status update (cycle $cycle):"
              echo "  üåê URL: $URL"
              echo "  ‚è∞ Uptime: $((cycle * 30 / 60)) minutes"
              echo "  ‚úÖ FastAPI: $fastapi_healthy"
              echo "  ‚úÖ Tunnel: $tunnel_healthy"
              echo "  üîÑ Failures: $consecutive_failures"
              
              # Test TTS functionality
              echo "üß™ Testing TTS functionality..."
              test_response=$(curl -s --max-time 30 -X POST "$URL/tts" \
                -H "Content-Type: application/json" \
                -d '{"text": "Hello, this is a test message", "voice": "expr-voice-2-f"}' 2>/dev/null)
              
              if echo "$test_response" | grep -q '"status":"success"'; then
                echo "‚úÖ TTS test successful"
              else
                echo "‚ö†Ô∏è TTS test failed: $test_response"
              fi
            fi
            
            # Progressive sleep intervals to reduce resource usage
            if [ $cycle -lt 120 ]; then
              sleep 30  # First hour: check every 30 seconds
            elif [ $cycle -lt 720 ]; then
              sleep 60  # Next 10 hours: check every minute
            else
              sleep 120 # After that: check every 2 minutes
            fi
          done
          
      - name: üõë Graceful Shutdown and Cleanup
        if: always()
        run: |
          echo "üõë Performing graceful shutdown..."
          
          # Show final statistics
          source monitor.sh
          echo "üìä FINAL SYSTEM STATISTICS:"
          show_system_stats
          
          # Get final metrics from API
          echo "üìà FINAL API METRICS:"
          curl -s --max-time 10 http://localhost:8000/metrics || echo "Metrics unavailable"
          
          # Graceful shutdown of services
          echo "üîÑ Stopping services gracefully..."
          
          # Signal FastAPI to shutdown gracefully
          if [ -f fastapi.pid ] && kill -0 $(cat fastapi.pid) 2>/dev/null; then
            echo "üì§ Sending SIGTERM to FastAPI..."
            kill -TERM $(cat fastapi.pid) 2>/dev/null || true
            sleep 10
            
            # Force kill if still running
            if kill -0 $(cat fastapi.pid) 2>/dev/null; then
              echo "üì§ Force killing FastAPI..."
              kill -KILL $(cat fastapi.pid) 2>/dev/null || true
            fi
          fi
          
          # Stop tunnel
          if [ -f tunnel.pid ] && kill -0 $(cat tunnel.pid) 2>/dev/null; then
            echo "üì§ Stopping tunnel..."
            kill $(cat tunnel.pid) 2>/dev/null || true
          fi
          
          # Cleanup processes
          pkill -f uvicorn || true
          pkill -f cloudflared || true
          
          # Show final logs
          echo "üìã ===== FINAL LOGS ====="
          echo "FastAPI logs (last 50 lines):"
          tail -50 fastapi.log 2>/dev/null || echo "No FastAPI logs"
          echo ""
          echo "Tunnel logs (last 20 lines):"
          tail -20 tunnel.log 2>/dev/null || echo "No tunnel logs"
          echo ""
          
          # Archive logs and important files
          echo "üì¶ Archiving session data..."
          mkdir -p session_archive
          cp fastapi.log session_archive/ 2>/dev/null || true
          cp tunnel.log session_archive/ 2>/dev/null || true
          cp service_info.json session_archive/ 2>/dev/null || true
          cp kittentts.log session_archive/ 2>/dev/null || true
          
          # Final status
          echo "‚úÖ Shutdown completed successfully"
          echo "üìä Session archived in session_archive/"
