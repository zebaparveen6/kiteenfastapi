name: Production KittenTTS FastAPI with Advanced Caching

on:
  workflow_dispatch:
  repository_dispatch:
    types: [restart-tts]
  push:

env:
  PYTHON_VERSION: "3.10"
  NODE_VERSION: "18"
  CACHE_VERSION: "v2"
  PIP_CACHE_DIR: /tmp/.pip-cache
  MODEL_CACHE_DIR: /tmp/.model-cache
  SYSTEM_CACHE_DIR: /tmp/.system-cache

jobs:
  serve:
    runs-on: ubuntu-latest
    timeout-minutes: 1440  # 24 hours max timeout
    
    steps:
      - name: üìã Show Machine Specifications
        run: |
          echo "üñ•Ô∏è ===== MACHINE SPECIFICATIONS ====="
          echo "CPU Information:"
          lscpu | head -20
          echo ""
          echo "Memory Information:"
          free -h
          echo ""
          echo "Disk Information:"
          df -h
          echo ""
          echo "Operating System:"
          uname -a
          cat /etc/os-release | head -5
          echo ""
          echo "Available Python versions:"
          ls /usr/bin/python* 2>/dev/null || echo "None found"
          echo ""
          echo "Network Information:"
          ip addr show | grep inet | head -5
          echo ""
          echo "Environment Variables:"
          env | grep -E "(GITHUB|RUNNER)" | head -10
          echo "üñ•Ô∏è ===== END SPECIFICATIONS ====="
          
      - name: üì¶ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: üíæ Cache System Dependencies
        uses: actions/cache@v4
        id: cache-system
        with:
          path: |
            ${{ env.SYSTEM_CACHE_DIR }}
            /usr/local/lib/python${{ env.PYTHON_VERSION }}/site-packages
            ~/.cache/pip
          key: system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', '**/setup.py') }}
          restore-keys: |
            system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.PYTHON_VERSION }}-
            system-deps-${{ env.CACHE_VERSION }}-${{ runner.os }}-
            system-deps-
            
      - name: üêç Setup Python with Caching
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: |
            **/requirements.txt
            **/setup.py
            
      - name: üíæ Cache ML Models & KittenTTS
        uses: actions/cache@v4
        id: cache-models
        with:
          path: |
            ${{ env.MODEL_CACHE_DIR }}
            ~/.cache/huggingface
            ~/.cache/torch
            ~/.local/share/kittentts
            ~/kittentts_models
          key: models-${{ env.CACHE_VERSION }}-kittentts-v0.1.0-${{ runner.os }}
          restore-keys: |
            models-${{ env.CACHE_VERSION }}-kittentts-
            models-${{ env.CACHE_VERSION }}-
            models-
            
      - name: üíæ Cache Node.js for Monitoring Tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            /usr/local/lib/node_modules
          key: node-${{ env.CACHE_VERSION }}-${{ runner.os }}-${{ env.NODE_VERSION }}
          restore-keys: |
            node-${{ env.CACHE_VERSION }}-${{ runner.os }}-
            node-${{ env.CACHE_VERSION }}-
            
      - name: üîß Install System Dependencies with Retry Logic
        run: |
          echo "üîß Installing system dependencies with caching..."
          
          # Create cache directories
          mkdir -p "${{ env.PIP_CACHE_DIR }}"
          mkdir -p "${{ env.MODEL_CACHE_DIR }}"
          mkdir -p "${{ env.SYSTEM_CACHE_DIR }}"
          
          # Function for retry logic
          retry_command() {
            local cmd="$1"
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• All attempts failed"
                  return 1
                fi
                sleep $((attempt * 2))
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Update package lists with retry
          retry_command "sudo apt-get update -qq"
          
          # Install system packages
          echo "Installing system audio libraries..."
          retry_command "sudo apt-get install -y -qq \
            ffmpeg \
            libsndfile1-dev \
            libasound2-dev \
            portaudio19-dev \
            libportaudio2 \
            libportaudiocpp0 \
            python3-dev \
            build-essential \
            curl \
            wget \
            htop \
            iotop \
            nethogs \
            sysstat"
            
          echo "‚úÖ System dependencies installed successfully"

      - name: üêç Install Python Dependencies with Bulletproof Error Handling
        run: |
          echo "üêç Installing Python dependencies with robust error handling..."
          
          # Define retry function with better error handling
          retry_command() {
            local cmd="$1"
            local description="$2"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üì¶ $description (attempt $attempt/$max_attempts)"
              
              if eval "$cmd"; then
                echo "‚úÖ $description succeeded"
                return 0
              else
                local exit_code=$?
                echo "‚ùå $description failed with exit code $exit_code"
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• All attempts failed for: $description"
                  return $exit_code
                fi
                
                echo "‚è≥ Waiting before retry..."
                sleep $((attempt * 3))
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Upgrade pip and essential tools first
          echo "üîß Upgrading pip and build tools..."
          retry_command "python -m pip install --upgrade pip setuptools wheel --cache-dir='${{ env.PIP_CACHE_DIR }}'" "pip upgrade"
          
          # Create corrected requirements.txt with proper PyTorch syntax
          echo "üìù Creating corrected requirements.txt..."
          cat > requirements_fixed.txt << 'EOF'
          # Core FastAPI dependencies (pinned for stability)
          fastapi==0.104.1
          uvicorn[standard]==0.24.0
          pydantic==2.5.0
          
          # Audio processing essentials
          soundfile==0.12.1
          numpy==1.24.4
          scipy==1.11.4
          
          # Optional audio libraries (installed separately)
          # librosa==0.10.1
          # pydub==0.25.1
          
          # Core ML dependencies (without local version specifiers)
          transformers==4.35.2
          tokenizers==0.15.0
          huggingface-hub==0.19.4
          
          # System monitoring
          psutil==5.9.6
          
          # HTTP & networking
          httpx==0.25.2
          aiofiles==23.2.1
          python-multipart==0.0.6
          
          # Utilities
          python-dotenv==1.0.0
          typing-extensions==4.8.0
          EOF
          
          # Install core dependencies first (most stable)
          echo "üéØ Installing core FastAPI dependencies..."
          retry_command "pip install fastapi==0.104.1 'uvicorn[standard]==0.24.0' pydantic==2.5.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Core FastAPI packages"
          
          # Install system dependencies
          echo "‚öôÔ∏è Installing system dependencies..."
          retry_command "pip install psutil==5.9.6 aiofiles==23.2.1 python-multipart==0.0.6 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "System packages"
          
          # Install audio processing (essential)
          echo "üéµ Installing audio processing dependencies..."
          retry_command "pip install soundfile==0.12.1 numpy==1.24.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Audio essentials"
          
          # Install PyTorch CPU version (separate command to handle special index)
          echo "üî• Installing PyTorch CPU version..."
          retry_command "pip install torch==2.1.0+cpu torchaudio==2.1.0+cpu --index-url https://download.pytorch.org/whl/cpu --cache-dir='${{ env.PIP_CACHE_DIR }}'" "PyTorch CPU"
          
          # Fallback PyTorch installation if CPU version fails
          if ! python -c "import torch" 2>/dev/null; then
            echo "‚ö†Ô∏è CPU PyTorch failed, installing regular PyTorch..."
            retry_command "pip install torch==2.1.0 torchaudio==2.1.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "PyTorch regular"
          fi
          
          # Install Hugging Face dependencies
          echo "ü§ó Installing Hugging Face dependencies..."
          retry_command "pip install transformers==4.35.2 tokenizers==0.15.0 huggingface-hub==0.19.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Hugging Face"
          
          # Install remaining utilities
          echo "üîß Installing utility packages..."
          retry_command "pip install httpx==0.25.2 python-dotenv==1.0.0 typing-extensions==4.8.0 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Utilities"
          
          # Install optional audio libraries (non-critical)
          echo "üéº Installing optional audio libraries..."
          
          # Try scipy first
          if ! retry_command "pip install scipy==1.11.4 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "SciPy"; then
            echo "‚ö†Ô∏è SciPy installation failed, trying older version..."
            retry_command "pip install scipy==1.10.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "SciPy fallback" || echo "‚ö†Ô∏è SciPy installation failed, continuing without it"
          fi
          
          # Try librosa (often problematic)
          if ! retry_command "pip install librosa==0.10.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Librosa"; then
            echo "‚ö†Ô∏è Librosa installation failed, installing minimal audio processing..."
            retry_command "pip install librosa --no-deps --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Librosa no-deps" || echo "‚ö†Ô∏è Continuing without librosa"
          fi
          
          # Try pydub (usually works)
          retry_command "pip install pydub==0.25.1 --cache-dir='${{ env.PIP_CACHE_DIR }}'" "Pydub" || echo "‚ö†Ô∏è Continuing without pydub"
          
          # Comprehensive verification
          echo "üîç Verifying critical installations..."
          
          python3 -c "
          import sys
          
          critical_packages = [
              ('fastapi', 'FastAPI'),
              ('uvicorn', 'Uvicorn'),
              ('pydantic', 'Pydantic'),
              ('soundfile', 'SoundFile'),
              ('numpy', 'NumPy'),
              ('psutil', 'PSUtil'),
              ('aiofiles', 'AIOFiles')
          ]
          
          optional_packages = [
              ('torch', 'PyTorch'),
              ('transformers', 'Transformers'),
              ('huggingface_hub', 'Hugging Face Hub'),
              ('scipy', 'SciPy'),
              ('librosa', 'Librosa'),
              ('pydub', 'Pydub')
          ]
          
          print('=== CRITICAL PACKAGE VERIFICATION ===')
          critical_failed = []
          
          for module, name in critical_packages:
              try:
                  __import__(module)
                  print(f'‚úÖ {name}: OK')
              except ImportError as e:
                  print(f'‚ùå {name}: FAILED - {e}')
                  critical_failed.append(name)
          
          print('\\n=== OPTIONAL PACKAGE VERIFICATION ===')
          for module, name in optional_packages:
              try:
                  __import__(module)
                  print(f'‚úÖ {name}: OK')
              except ImportError as e:
                  print(f'‚ö†Ô∏è {name}: Not available - {e}')
          
          if critical_failed:
              print(f'\\n‚ùå CRITICAL FAILURE: Missing packages: {critical_failed}')
              print('The FastAPI server may not work properly.')
              sys.exit(1)
          else:
              print('\\n‚úÖ All critical packages verified successfully!')
              print('FastAPI server should work correctly.')
          "
          
          # Final installation summary
          echo "üìä Installation Summary:"
          pip list | grep -E "(fastapi|uvicorn|pydantic|torch|transformers|soundfile|numpy)" || echo "No matching packages found"
          
          echo "‚úÖ Python dependencies installation completed"
        
      - name: üê± Install KittenTTS with Caching & Error Handling
        run: |
          echo "üê± Installing KittenTTS..."
          
          # Set up model cache environment
          export HF_HOME="${{ env.MODEL_CACHE_DIR }}/huggingface"
          export TRANSFORMERS_CACHE="${{ env.MODEL_CACHE_DIR }}/transformers"
          export HF_HUB_CACHE="${{ env.MODEL_CACHE_DIR }}/hub"
          
          mkdir -p "$HF_HOME" "$TRANSFORMERS_CACHE" "$HF_HUB_CACHE"
          
          # Function to install KittenTTS with multiple methods
          install_kittentts() {
            echo "Method 1: Installing from PyPI..."
            if pip install kittentts --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from PyPI"
              return 0
            fi
            
            echo "Method 2: Installing from GitHub release..."
            if pip install https://github.com/KittenML/KittenTTS/releases/download/0.1/kittentts-0.1.0-py3-none-any.whl --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from GitHub"
              return 0
            fi
            
            echo "Method 3: Installing from source..."
            if pip install git+https://github.com/KittenML/KittenTTS.git --cache-dir="${{ env.PIP_CACHE_DIR }}"; then
              echo "‚úÖ KittenTTS installed from source"
              return 0
            fi
            
            echo "‚ùå All KittenTTS installation methods failed"
            return 1
          }
          
          # Try to install KittenTTS
          if ! install_kittentts; then
            echo "‚ö†Ô∏è KittenTTS installation failed, but continuing..."
            echo "Will attempt runtime installation in the API"
          fi
          
          # Pre-download models if possible
          echo "üì• Pre-downloading KittenTTS models..."
          python3 -c "
          try:
              from huggingface_hub import snapshot_download
              import os
              
              cache_dir = '${{ env.MODEL_CACHE_DIR }}/huggingface'
              os.makedirs(cache_dir, exist_ok=True)
              
              print('Downloading KittenTTS nano model...')
              snapshot_download(
                  repo_id='KittenML/kitten-tts-nano-0.1',
                  cache_dir=cache_dir,
                  resume_download=True,
                  local_files_only=False
              )
              print('‚úÖ Model downloaded successfully')
              
          except Exception as e:
              print(f'‚ö†Ô∏è Model pre-download failed: {e}')
              print('Models will be downloaded at runtime')
          " || echo "‚ö†Ô∏è Model pre-download skipped"
          
          echo "‚úÖ KittenTTS setup completed"
          
      - name: üîß Setup Monitoring Tools
        run: |
          echo "üîß Setting up monitoring tools..."
          
          # Install system monitoring tools
          sudo apt-get install -y -qq htop iotop nethogs sysstat lsof
          
          # Create monitoring script
          cat > monitor.sh << 'EOF'
          #!/bin/bash
          
          show_system_stats() {
            echo "üìä ===== SYSTEM MONITORING $(date) ====="
            
            # CPU Usage
            echo "üî• CPU Usage:"
            top -bn1 | grep "Cpu(s)" | head -1
            
            # Memory Usage
            echo "üíæ Memory Usage:"
            free -h | head -2
            
            # Disk Usage
            echo "üíø Disk Usage:"
            df -h / | tail -1
            
            # Network Stats
            echo "üåê Network:"
            ss -tuln | grep :8000 || echo "Port 8000: Not listening"
            
            # Process Stats
            echo "‚öôÔ∏è Top Processes (CPU):"
            ps aux --sort=-%cpu | head -6
            
            # Load Average
            echo "üìà Load Average:"
            uptime
            
            # Temperature (if available)
            if command -v sensors &> /dev/null; then
              echo "üå°Ô∏è Temperature:"
              sensors | grep -E "(Core|temp)" | head -3 || echo "No temperature sensors found"
            fi
            
            echo "üìä ===== END MONITORING ====="
            echo ""
          }
          
          # Export function for use
          export -f show_system_stats
          EOF
          
          chmod +x monitor.sh
          source monitor.sh
          
          echo "‚úÖ Monitoring tools ready"
          
      - name: üìù Create Bulletproof FastAPI Server
        run: |
          if [ ! -f main.py ]; then
            echo "üìù Creating production FastAPI server..."
            
            # Create the enhanced server (content from the second artifact)
            cat > main.py << 'FASTAPI_EOF'
          from fastapi import FastAPI, HTTPException, BackgroundTasks, Request
          from fastapi.responses import JSONResponse, FileResponse, StreamingResponse
          from fastapi.middleware.cors import CORSMiddleware
          from fastapi.staticfiles import StaticFiles
          from fastapi.middleware.gzip import GZipMiddleware
          from pydantic import BaseModel, Field
          import uvicorn
          import logging
          import sys
          import os
          import uuid
          import asyncio
          import aiofiles
          import soundfile as sf
          import numpy as np
          from typing import Optional, List, Dict, Any
          import tempfile
          import threading
          from datetime import datetime, timedelta
          import json
          import gc
          import psutil
          import time
          import traceback
          from contextlib import asynccontextmanager
          import signal
          import weakref
          from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
          import multiprocessing as mp
          from functools import wraps, lru_cache
          import hashlib
          import pickle
          from pathlib import Path
          import shutil
          
          # Enhanced logging configuration
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(sys.stdout),
                  logging.FileHandler('kittentts.log', mode='a')
              ]
          )
          logger = logging.getLogger(__name__)
          
          # Global configuration
          class Config:
              AUDIO_DIR = Path("audio_files")
              CACHE_DIR = Path("cache")
              MODEL_CACHE_DIR = Path(os.environ.get("MODEL_CACHE_DIR", "~/.cache/kittentts")).expanduser()
              MAX_TEXT_LENGTH = 10000
              MAX_CONCURRENT_REQUESTS = 10
              CLEANUP_INTERVAL = 3600  # 1 hour
              MAX_AUDIO_FILES = 100
              MEMORY_THRESHOLD = 0.85  # 85% memory usage threshold
              CPU_THRESHOLD = 0.90     # 90% CPU usage threshold
              
          config = Config()
          
          # Create directories
          for directory in [config.AUDIO_DIR, config.CACHE_DIR, config.MODEL_CACHE_DIR]:
              directory.mkdir(parents=True, exist_ok=True)
          
          # Global variables
          tts_model = None
          model_lock = threading.RLock()  # Re-entrant lock
          request_semaphore = asyncio.Semaphore(config.MAX_CONCURRENT_REQUESTS)
          executor = ThreadPoolExecutor(max_workers=min(4, (os.cpu_count() or 1) + 1))
          
          # Memory-safe cache for generated audio
          audio_cache = weakref.WeakValueDictionary()
          
          # Metrics tracking
          class Metrics:
              def __init__(self):
                  self.requests_total = 0
                  self.requests_success = 0
                  self.requests_failed = 0
                  self.average_generation_time = 0.0
                  self.model_load_time = 0.0
                  self.last_reset = datetime.now()
                  self.active_requests = 0
                  self._lock = threading.Lock()
              
              def record_request(self, success: bool, generation_time: float = 0.0):
                  with self._lock:
                      self.requests_total += 1
                      if success:
                          self.requests_success += 1
                          if generation_time > 0:
                              self.average_generation_time = (
                                  (self.average_generation_time * (self.requests_success - 1) + generation_time) 
                                  / self.requests_success
                              )
                      else:
                          self.requests_failed += 1
              
              def get_stats(self) -> Dict[str, Any]:
                  with self._lock:
                      return {
                          "requests_total": self.requests_total,
                          "requests_success": self.requests_success,
                          "requests_failed": self.requests_failed,
                          "success_rate": (
                              self.requests_success / max(1, self.requests_total) * 100
                          ),
                          "average_generation_time": round(self.average_generation_time, 3),
                          "model_load_time": round(self.model_load_time, 3),
                          "active_requests": self.active_requests,
                          "uptime": str(datetime.now() - self.last_reset)
                      }
          
          metrics = Metrics()
          
          # Enhanced request/response models
          class TTSRequest(BaseModel):
              text: str = Field(..., min_length=1, max_length=config.MAX_TEXT_LENGTH)
              voice: Optional[str] = Field(default="expr-voice-2-f")
              speed: Optional[float] = Field(default=1.0, ge=0.25, le=3.0)
              language: Optional[str] = Field(default="en")
              format: Optional[str] = Field(default="wav")
              quality: Optional[str] = Field(default="standard")  # standard, high
              telegram_chat_id: Optional[str] = None
              telegram_bot_token: Optional[str] = None
              cache_key: Optional[str] = None
              
              def generate_cache_key(self) -> str:
                  """Generate a unique cache key for this request"""
                  content = f"{self.text}_{self.voice}_{self.speed}_{self.format}_{self.quality}"
                  return hashlib.md5(content.encode()).hexdigest()
          
          class TTSResponse(BaseModel):
              text: str
              status: str
              audio_url: Optional[str] = None
              audio_file_path: Optional[str] = None
              file_id: Optional[str] = None
              message: Optional[str] = None
              telegram_ready: Optional[bool] = False
              duration: Optional[float] = None
              sample_rate: Optional[int] = None
              cache_hit: Optional[bool] = False
              generation_time: Optional[float] = None
              model_version: Optional[str] = None
          
          class VoiceInfo(BaseModel):
              name: str
              gender: str
              language: str
              description: str
              quality: str = "standard"
              sample_rate: int = 24000
          
          # Memory management utilities
          def check_memory_usage() -> Dict[str, float]:
              """Check current memory usage"""
              process = psutil.Process()
              memory_info = process.memory_info()
              memory_percent = process.memory_percent()
              
              return {
                  "memory_mb": memory_info.rss / 1024 / 1024,
                  "memory_percent": memory_percent,
                  "available_mb": psutil.virtual_memory().available / 1024 / 1024,
                  "system_memory_percent": psutil.virtual_memory().percent
              }
          
          def cleanup_memory():
              """Force garbage collection and cleanup"""
              try:
                  gc.collect()
                  if hasattr(gc, 'set_threshold'):
                      gc.set_threshold(700, 10, 10)  # More aggressive GC
                  logger.info("Memory cleanup completed")
              except Exception as e:
                  logger.warning(f"Memory cleanup failed: {e}")
          
          # Cache management
          class AudioCache:
              def __init__(self, max_size: int = 50):
                  self.cache = {}
                  self.access_times = {}
                  self.max_size = max_size
                  self._lock = threading.RLock()
              
              def get(self, key: str) -> Optional[bytes]:
                  with self._lock:
                      if key in self.cache:
                          self.access_times[key] = time.time()
                          return self.cache[key]
                      return None
              
              def set(self, key: str, data: bytes):
                  with self._lock:
                      if len(self.cache) >= self.max_size:
                          self._evict_oldest()
                      self.cache[key] = data
                      self.access_times[key] = time.time()
              
              def _evict_oldest(self):
                  if not self.access_times:
                      return
                  oldest_key = min(self.access_times, key=self.access_times.get)
                  self.cache.pop(oldest_key, None)
                  self.access_times.pop(oldest_key, None)
              
              def clear(self):
                  with self._lock:
                      self.cache.clear()
                      self.access_times.clear()
          
          audio_file_cache = AudioCache()
          
          # Enhanced error handling decorator
          def handle_errors(func):
              @wraps(func)
              async def wrapper(*args, **kwargs):
                  try:
                      return await func(*args, **kwargs)
                  except HTTPException:
                      raise
                  except Exception as e:
                      logger.error(f"Unexpected error in {func.__name__}: {str(e)}")
                      logger.error(traceback.format_exc())
                      
                      # Try to recover
                      cleanup_memory()
                      
                      raise HTTPException(
                          status_code=500,
                          detail={
                              "error": "Internal server error",
                              "message": str(e),
                              "function": func.__name__,
                              "recoverable": True
                          }
                      )
              return wrapper
          
          # KittenTTS initialization with multiple fallback methods
          async def initialize_kitten_tts() -> bool:
              """Initialize KittenTTS with comprehensive error handling"""
              global tts_model, metrics
              
              start_time = time.time()
              
              try:
                  logger.info("üê± Starting KittenTTS initialization...")
                  
                  # Method 1: Standard import
                  try:
                      from kittentts import KittenTTS
                      logger.info("‚úÖ KittenTTS module imported successfully")
                  except ImportError as e:
                      logger.warning(f"KittenTTS import failed: {e}")
                      
                      # Method 2: Try installing at runtime
                      logger.info("üì¶ Attempting runtime installation...")
                      import subprocess
                      
                      install_commands = [
                          [sys.executable, "-m", "pip", "install", "kittentts"],
                          [sys.executable, "-m", "pip", "install", 
                           "https://github.com/KittenML/KittenTTS/releases/download/0.1/kittentts-0.1.0-py3-none-any.whl"],
                          [sys.executable, "-m", "pip", "install", "git+https://github.com/KittenML/KittenTTS.git"]
                      ]
                      
                      for cmd in install_commands:
                          try:
                              subprocess.check_call(cmd, timeout=300)
                              from kittentts import KittenTTS
                              logger.info("‚úÖ KittenTTS installed and imported successfully")
                              break
                          except Exception as install_error:
                              logger.warning(f"Install attempt failed: {install_error}")
                              continue
                      else:
                          logger.error("‚ùå All KittenTTS installation attempts failed")
                          return False
                  
                  # Initialize model with retry logic
                  model_attempts = [
                      "KittenML/kitten-tts-nano-0.1",
                      "kitten-tts-nano-0.1",
                      "nano"
                  ]
                  
                  for model_name in model_attempts:
                      try:
                          logger.info(f"üîÑ Attempting to load model: {model_name}")
                          
                          with model_lock:
                              # Set cache directory
                              os.environ["HF_HOME"] = str(config.MODEL_CACHE_DIR)
                              os.environ["TRANSFORMERS_CACHE"] = str(config.MODEL_CACHE_DIR / "transformers")
                              
                              tts_model = KittenTTS(model_name)
                              
                              # Test the model
                              test_audio = tts_model.generate("Test", voice="expr-voice-2-f")
                              if test_audio is not None and len(test_audio) > 0:
                                  logger.info(f"‚úÖ Model {model_name} loaded and tested successfully")
                                  break
                              else:
                                  logger.warning(f"Model {model_name} loaded but test failed")
                                  tts_model = None
                      
                      except Exception as model_error:
                          logger.warning(f"Model {model_name} failed: {model_error}")
                          tts_model = None
                          continue
                  
                  if tts_model is None:
                      logger.error("‚ùå All model loading attempts failed")
                      return False
                  
                  metrics.model_load_time = time.time() - start_time
                  logger.info(f"üéµ KittenTTS ready! Load time: {metrics.model_load_time:.2f}s")
                  return True
                  
              except Exception as e:
                  logger.error(f"‚ùå KittenTTS initialization failed: {e}")
                  logger.error(traceback.format_exc())
                  return False
          
          # Enhanced voice configuration
          @lru_cache(maxsize=1)
          def get_available_voices() -> List[VoiceInfo]:
              """Get list of available KittenTTS voices with caching"""
              voices = [
                  VoiceInfo(name="expr-voice-1-m", gender="male", language="en", description="Expressive male voice 1", quality="standard"),
                  VoiceInfo(name="expr-voice-1-f", gender="female", language="en", description="Expressive female voice 1", quality="standard"),
                  VoiceInfo(name="expr-voice-2-m", gender="male", language="en", description="Expressive male voice 2", quality="high"),
                  VoiceInfo(name="expr-voice-2-f", gender="female", language="en", description="Expressive female voice 2", quality="high"),
                  VoiceInfo(name="expr-voice-3-m", gender="male", language="en", description="Expressive male voice 3", quality="standard"),
                  VoiceInfo(name="expr-voice-3-f", gender="female", language="en", description="Expressive female voice 3", quality="standard"),
                  VoiceInfo(name="expr-voice-4-m", gender="male", language="en", description="Expressive male voice 4", quality="high"),
                  VoiceInfo(name="expr-voice-4-f", gender="female", language="en", description="Expressive female voice 4", quality="high"),
                  VoiceInfo(name="expr-voice-5-m", gender="male", language="en", description="Expressive male voice 5", quality="standard"),
                  VoiceInfo(name="expr-voice-5-f", gender="female", language="en", description="Expressive female voice 5", quality="standard")
              ]
              return voices
          
          # Text preprocessing and chunking
          def preprocess_text(text: str) -> List[str]:
              """Preprocess and chunk text for optimal TTS generation"""
              if not text or not text.strip():
                  raise ValueError("Text cannot be empty")
              
              # Clean text
              text = text.strip()
              
              # Handle very long texts by chunking
              if len(text) <= 500:
                  return [text]
              
              # Split by sentences, keeping punctuation
              import re
              sentences = re.split(r'(?<=[.!?])\s+', text)
              
              chunks = []
              current_chunk = ""
              
              for sentence in sentences:
                  if len(current_chunk) + len(sentence) <= 500:
                      current_chunk += (" " if current_chunk else "") + sentence
                  else:
                      if current_chunk:
                          chunks.append(current_chunk.strip())
                      current_chunk = sentence
              
              if current_chunk:
                  chunks.append(current_chunk.strip())
              
              return chunks if chunks else [text]
          
          # Enhanced audio generation with chunking support
          async def generate_audio_with_chunking(
              text: str,
              voice: str = "expr-voice-2-f",
              speed: float = 1.0,
              format: str = "wav",
              cache_key: Optional[str] = None
          ) -> tuple[str, float, int]:
              """Generate audio with support for long texts and caching"""
              
              global tts_model, metrics
              
              if tts_model is None:
                  raise HTTPException(status_code=503, detail="TTS model not initialized")
              
              # Check cache first
              if cache_key:
                  cached_data = audio_file_cache.get(cache_key)
                  if cached_data:
                      logger.info(f"üìã Cache hit for key: {cache_key[:8]}...")
                      # Write cached data to file
                      filename = f"{uuid.uuid4()}.{format}"
                      file_path = config.AUDIO_DIR / filename
                      
                      async with aiofiles.open(file_path, 'wb') as f:
                          await f.write(cached_data)
                      
                      # Get audio info
                      audio_data, sample_rate = sf.read(str(file_path))
                      duration = len(audio_data) / sample_rate
                      
                      return str(filename), duration, sample_rate
              
              start_time = time.time()
              
              try:
                  # Preprocess text into chunks
                  text_chunks = preprocess_text(text)
                  logger.info(f"üìù Processing {len(text_chunks)} text chunks")
                  
                  # Generate audio for each chunk
                  audio_segments = []
                  total_duration = 0.0
                  sample_rate = 24000  # KittenTTS default
                  
                  for i, chunk in enumerate(text_chunks):
                      logger.info(f"üéµ Generating chunk {i+1}/{len(text_chunks)}: '{chunk[:30]}...'")
                      
                      # Check memory before processing
                      memory_stats = check_memory_usage()
                      if memory_stats["system_memory_percent"] > 85:
                          logger.warning("‚ö†Ô∏è High memory usage, forcing cleanup")
                          cleanup_memory()
                      
                      # Generate audio with timeout and retry
                      chunk_audio = await asyncio.wait_for(
                          asyncio.get_event_loop().run_in_executor(
                              executor,
                              lambda: generate_chunk_audio(chunk, voice)
                          ),
                          timeout=120.0  # 2 minutes per chunk
                      )
                      
                      if chunk_audio is not None and len(chunk_audio) > 0:
                          audio_segments.append(chunk_audio)
                          chunk_duration = len(chunk_audio) / sample_rate
                          total_duration += chunk_duration
                          logger.info(f"‚úÖ Chunk {i+1} completed ({chunk_duration:.2f}s)")
                      else:
                          logger.error(f"‚ùå Chunk {i+1} generation failed")
                          raise Exception(f"Audio generation failed for chunk {i+1}")
                  
                  # Combine all audio segments
                  if len(audio_segments) == 1:
                      final_audio = audio_segments[0]
                  else:
                      # Add small silence between chunks (0.1 seconds)
                      silence = np.zeros(int(sample_rate * 0.1))
                      combined_audio = []
                      
                      for i, segment in enumerate(audio_segments):
                          combined_audio.append(segment)
                          if i < len(audio_segments) - 1:  # Don't add silence after last segment
                              combined_audio.append(silence)
                      
                      final_audio = np.concatenate(combined_audio)
                  
                  # Apply speed modification
                  if speed != 1.0:
                      final_audio = modify_audio_speed(final_audio, speed, sample_rate)
                  
                  # Generate filename and save
                  file_id = str(uuid.uuid4())
                  filename = f"{file_id}.{format.lower()}"
                  file_path = config.AUDIO_DIR / filename
                  
                  # Save audio file
                  sf.write(str(file_path), final_audio, sample_rate)
                  
                  # Convert format if needed
                  if format.lower() != "wav":
                      await convert_audio_format(str(file_path), format.lower())
                  
                  # Cache the result
                  if cache_key:
                      try:
                          with open(file_path, 'rb') as f:
                              audio_file_cache.set(cache_key, f.read())
                      except Exception as cache_error:
                          logger.warning(f"Caching failed: {cache_error}")
                  
                  generation_time = time.time() - start_time
                  final_duration = len(final_audio) / sample_rate
                  
                  logger.info(f"‚úÖ Audio generation completed: {filename} ({final_duration:.2f}s, generated in {generation_time:.2f}s)")
                  
                  return str(filename), final_duration, sample_rate
                  
              except asyncio.TimeoutError:
                  logger.error("‚ùå Audio generation timed out")
                  raise HTTPException(status_code=408, detail="Audio generation timed out")
              except Exception as e:
                  logger.error(f"‚ùå Audio generation error: {str(e)}")
                  logger.error(traceback.format_exc())
                  raise HTTPException(status_code=500, detail=f"Audio generation failed: {str(e)}")
          
          def generate_chunk_audio(text: str, voice: str) -> np.ndarray:
              """Generate audio for a single chunk with error handling"""
              global tts_model
              
              max_retries = 3
              retry_delay = 1.0
              
              for attempt in range(max_retries):
                  try:
                      with model_lock:
                          if tts_model is None:
                              raise Exception("TTS model not available")
                          
                          # Generate audio
                          audio_data = tts_model.generate(text, voice=voice)
                          
                          if audio_data is None or len(audio_data) == 0:
                              raise Exception("Model returned empty audio data")
                          
                          return audio_data
                  
                  except Exception as e:
                      logger.warning(f"Chunk generation attempt {attempt + 1} failed: {e}")
                      
                      if attempt == max_retries - 1:
                          # Last attempt failed
                          raise Exception(f"Chunk generation failed after {max_retries} attempts: {e}")
                      
                      # Wait before retry
                      time.sleep(retry_delay * (attempt + 1))
                      
                      # Try to recover
                      try:
                          cleanup_memory()
                      except:
                          pass
          
          def modify_audio_speed(audio: np.ndarray, speed: float, sample_rate: int) -> np.ndarray:
              """Modify audio speed with quality preservation"""
              try:
                  if speed == 1.0:
                      return audio
                  
                  if speed > 1.0:
                      # Speed up: time-stretch without pitch change
                      try:
                          import librosa
                          return librosa.effects.time_stretch(audio, rate=speed)
                      except ImportError:
                          # Fallback: simple resampling
                          step = max(1, int(speed))
                          return audio[::step]
                  else:
                      # Slow down: interpolation
                      try:
                          import librosa
                          return librosa.effects.time_stretch(audio, rate=speed)
                      except ImportError:
                          # Fallback: scipy interpolation
                          try:
                              from scipy import signal
                              return signal.resample(audio, int(len(audio) / speed))
                          except ImportError:
                              # Simple repetition fallback
                              repeat_factor = max(1, int(1.0 / speed))
                              return np.repeat(audio, repeat_factor)
              
              except Exception as e:
                  logger.warning(f"Speed modification failed: {e}, using original speed")
                  return audio
          
          async def convert_audio_format(file_path: str, target_format: str):
              """Convert audio to different formats with error handling"""
              try:
                  original_path = Path(file_path)
                  new_path = original_path.with_suffix(f".{target_format}")
                  
                  if target_format == "wav":
                      return  # Already WAV
                  
                  # Try pydub first
                  try:
                      from pydub import AudioSegment
                      audio = AudioSegment.from_wav(str(original_path))
                      
                      export_params = {"format": target_format}
                      if target_format == "mp3":
                          export_params.update({"bitrate": "128k"})
                      elif target_format == "ogg":
                          export_params.update({"codec": "libvorbis"})
                      
                      audio.export(str(new_path), **export_params)
                      original_path.unlink()  # Remove original
                      logger.info(f"‚úÖ Converted to {target_format.upper()}: {new_path.name}")
                      
                  except ImportError:
                      # Fallback: use ffmpeg directly
                      import subprocess
                      cmd = [
                          "ffmpeg", "-i", str(original_path), "-y",
                          "-acodec", "pcm_s16le" if target_format == "wav" else "libmp3lame" if target_format == "mp3" else "libvorbis",
                          str(new_path)
                      ]
                      
                      subprocess.run(cmd, check=True, capture_output=True)
                      original_path.unlink()
                      logger.info(f"‚úÖ Converted with ffmpeg to {target_format.upper()}")
              
              except Exception as e:
                  logger.warning(f"Format conversion failed: {e}, keeping original format")
          
          # Lifespan management
          @asynccontextmanager
          async def lifespan(app: FastAPI):
              # Startup
              logger.info("üöÄ KittenTTS API starting up...")
              
              # Initialize model in background
              model_task = asyncio.create_task(initialize_kitten_tts())
              
              # Start background monitoring
              monitor_task = asyncio.create_task(background_monitoring())
              
              # Start cleanup task
              cleanup_task = asyncio.create_task(periodic_cleanup())
              
              yield
              
              # Shutdown
              logger.info("üõë Shutting down KittenTTS API...")
              
              # Cancel background tasks
              for task in [monitor_task, cleanup_task]:
                  if not task.done():
                      task.cancel()
                      try:
                          await task
                      except asyncio.CancelledError:
                          pass
              
              # Cleanup
              cleanup_memory()
              executor.shutdown(wait=True)
          
          # Create FastAPI app with lifespan
          app = FastAPI(
              title="üê± KittenTTS Production API",
              description="Bulletproof KittenTTS implementation with caching, monitoring, and robust error handling",
              version="2.0.0",
              lifespan=lifespan
          )
          
          # Add middleware
          app.add_middleware(
              CORSMiddleware,
              allow_origins=["*"],
              allow_credentials=True,
              allow_methods=["*"],
              allow_headers=["*"],
          )
          
          app.add_middleware(GZipMiddleware, minimum_size=1000)
          
          # Mount static files
          app.mount("/audio", StaticFiles(directory=str(config.AUDIO_DIR)), name="audio")
          
          # Background monitoring
          async def background_monitoring():
              """Continuous system monitoring"""
              while True:
                  try:
                      await asyncio.sleep(30)  # Every 30 seconds
                      
                      # Get system stats
                      memory_stats = check_memory_usage()
                      cpu_percent = psutil.cpu_percent(interval=1)
                      
                      # Log stats periodically
                      if int(time.time()) % 300 == 0:  # Every 5 minutes
                          logger.info(f"üìä System: CPU {cpu_percent:.1f}%, Memory {memory_stats['system_memory_percent']:.1f}%, Available {memory_stats['available_mb']:.0f}MB")
                      
                      # Memory management
                      if memory_stats["system_memory_percent"] > config.MEMORY_THRESHOLD * 100:
                          logger.warning("‚ö†Ô∏è High memory usage detected, performing cleanup")
                          cleanup_memory()
                          audio_file_cache.clear()
                  
                  except Exception as e:
                      logger.warning(f"Background monitoring error: {e}")
          
          async def periodic_cleanup():
              """Periodic cleanup of old files"""
              while True:
                  try:
                      await asyncio.sleep(config.CLEANUP_INTERVAL)
                      
                      # Clean old audio files
                      audio_files = list(config.AUDIO_DIR.glob("*"))
                      if len(audio_files) > config.MAX_AUDIO_FILES:
                          # Sort by modification time and remove oldest
                          audio_files.sort(key=lambda f: f.stat().st_mtime)
                          files_to_remove = audio_files[:-config.MAX_AUDIO_FILES]
                          
                          for file_path in files_to_remove:
                              try:
                                  file_path.unlink()
                                  logger.info(f"üßπ Cleaned up old file: {file_path.name}")
                              except Exception as e:
                                  logger.warning(f"Failed to cleanup {file_path}: {e}")
                  
                  except Exception as e:
                      logger.warning(f"Periodic cleanup error: {e}")
          
          # API Routes
          @app.get("/")
          async def root():
              """Enhanced root endpoint with comprehensive information"""
              memory_stats = check_memory_usage()
              model_status = "‚úÖ Ready" if tts_model is not None else "‚è≥ Loading..."
              
              return {
                  "message": "üê± KittenTTS Production API",
                  "version": "2.0.0",
                  "status": "active",
                  "tts_model_status": model_status,
                  "system_info": {
                      "memory_usage_mb": round(memory_stats["memory_mb"], 1),
                      "memory_percent": round(memory_stats["memory_percent"], 1),
                      "available_memory_mb": round(memory_stats["available_mb"], 1),
                      "cpu_count": os.cpu_count(),
                      "python_version": sys.version.split()[0]
                  },
                  "endpoints": {
                      "health": "/health - Health check",
                      "tts": "/tts - Text to speech (POST)",
                      "voices": "/voices - Available voices",
                      "audio": "/audio/{filename} - Audio file access",
                      "status": "/status - Detailed status",
                      "metrics": "/metrics - Performance metrics",
                      "docs": "/docs - API documentation"
                  },
                  "features": [
                      "‚úÖ Real KittenTTS with chunking support",
                      "‚úÖ Robust error handling & recovery",
                      "‚úÖ Memory management & caching",
                      "‚úÖ System monitoring",
                      "‚úÖ Long text support (up to 10,000 chars)",
                      "‚úÖ Multiple audio formats",
                      "‚úÖ Telegram integration ready",
                      "‚úÖ Production-grade performance"
                  ],
                  "supported_voices": len(get_available_voices()),
                  "cache_enabled": True,
                  "metrics": metrics.get_stats()
              }
          
          @app.get("/health")
          async def health_check():
              """Comprehensive health check"""
              try:
                  model_ready = tts_model is not None
                  memory_stats = check_memory_usage()
                  cpu_percent = psutil.cpu_percent()
                  
                  # Test model if available
                  model_test_passed = False
                  if model_ready:
                      try:
                          # Quick model test
                          test_result = await asyncio.wait_for(
                              asyncio.get_event_loop().run_in_executor(
                                  executor,
                                  lambda: generate_chunk_audio("Test", "expr-voice-2-f")
                              ),
                              timeout=10.0
                          )
                          model_test_passed = test_result is not None and len(test_result) > 0
                      except Exception as test_error:
                          logger.warning(f"Model test failed: {test_error}")
                  
                  health_status = "healthy" if (model_ready and model_test_passed) else "degraded" if model_ready else "loading"
                  
                  return {
                      "status": health_status,
                      "service": "üê± KittenTTS Production API",
                      "model_loaded": model_ready,
                      "model_functional": model_test_passed,
                      "timestamp": datetime.now().isoformat(),
                      "system_health": {
                          "cpu_percent": round(cpu_percent, 1),
                          "memory_percent": round(memory_stats["system_memory_percent"], 1),
                          "available_memory_mb": round(memory_stats["available_mb"], 1),
                          "disk_usage_percent": round(psutil.disk_usage('/').percent, 1)
                      },
                      "service_health": {
                          "audio_files_count": len(list(config.AUDIO_DIR.glob("*"))),
                          "cache_size": len(audio_file_cache.cache),
                          "active_requests": metrics.active_requests,
                          "total_requests": metrics.requests_total
                      }
                  }
              
              except Exception as e:
                  logger.error(f"Health check failed: {e}")
                  return JSONResponse(
                      status_code=503,
                      content={
                          "status": "unhealthy",
                          "error": str(e),
                          "timestamp": datetime.now().isoformat()
                      }
                  )
          
          @app.post("/tts", response_model=TTSResponse)
          @handle_errors
          async def text_to_speech(request: TTSRequest, background_tasks: BackgroundTasks):
              """Production-grade TTS endpoint with bulletproof error handling"""
              
              async with request_semaphore:
                  metrics.active_requests += 1
                  start_time = time.time()
                  
                  try:
                      logger.info(f"üìù TTS request: '{request.text[:50]}...' voice='{request.voice}' (length: {len(request.text)})")
                      
                      # Validation
                      if not request.text or len(request.text.strip()) == 0:
                          raise HTTPException(status_code=400, detail="Text cannot be empty")
                      
                      if len(request.text) > config.MAX_TEXT_LENGTH:
                          raise HTTPException(
                              status_code=400, 
                              detail=f"Text too long (max {config.MAX_TEXT_LENGTH} characters, got {len(request.text)})"
                          )
                      
                      # Validate voice
                      available_voices = [v.name for v in get_available_voices()]
                      if request.voice not in available_voices:
                          logger.warning(f"Unknown voice '{request.voice}', using default")
                          request.voice = "expr-voice-2-f"
                      
                      # Generate cache key
                      cache_key = request.generate_cache_key()
                      
                      # Wait for model if still loading
                      max_wait = 300  # 5 minutes
                      wait_time = 0
                      while tts_model is None and wait_time < max_wait:
                          logger.info(f"‚è≥ Waiting for model to load... ({wait_time}s/{max_wait}s)")
                          await asyncio.sleep(5)
                          wait_time += 5
                      
                      if tts_model is None:
                          raise HTTPException(
                              status_code=503, 
                              detail="TTS model failed to load within timeout period"
                          )
                      
                      # Generate audio
                      filename, duration, sample_rate = await generate_audio_with_chunking(
                          text=request.text,
                          voice=request.voice,
                          speed=request.speed,
                          format=request.format,
                          cache_key=cache_key
                      )
                      
                      # Create response
                      audio_url = f"/audio/{filename}"
                      generation_time = time.time() - start_time
                      
                      response = TTSResponse(
                          text=request.text,
                          status="success",
                          audio_url=audio_url,
                          audio_file_path=audio_url,
                          file_id=filename.split('.')[0],
                          message=f"üéµ Audio generated successfully with {request.voice} (speed: {request.speed}x, duration: {duration:.2f}s, time: {generation_time:.2f}s)",
                          telegram_ready=True,
                          duration=duration,
                          sample_rate=sample_rate,
                          cache_hit=cache_key in audio_file_cache.cache,
                          generation_time=generation_time,
                          model_version="kitten-tts-nano-0.1"
                      )
                      
                      # Record success
                      metrics.record_request(True, generation_time)
                      logger.info(f"‚úÖ TTS completed successfully: {filename}")
                      
                      # Schedule cleanup
                      background_tasks.add_task(cleanup_file, filename, 7200)  # 2 hours
                      
                      return response
                      
                  except HTTPException:
                      metrics.record_request(False)
                      raise
                  except Exception as e:
                      metrics.record_request(False)
                      logger.error(f"‚ùå TTS generation error: {str(e)}")
                      logger.error(traceback.format_exc())
                      
                      # Try to provide a meaningful error response
                      error_detail = {
                          "error": "TTS generation failed",
                          "message": str(e),
                          "text_length": len(request.text),
                          "voice": request.voice,
                          "timestamp": datetime.now().isoformat(),
                          "suggestion": "Try with shorter text or different voice"
                      }
                      
                      raise HTTPException(status_code=500, detail=error_detail)
                  
                  finally:
                      metrics.active_requests -= 1
          
          @app.get("/metrics")
          async def get_metrics():
              """Get comprehensive performance metrics"""
              memory_stats = check_memory_usage()
              cpu_percent = psutil.cpu_percent()
              
              return {
                  "performance": metrics.get_stats(),
                  "system": {
                      "cpu_percent": round(cpu_percent, 1),
                      "memory_mb": round(memory_stats["memory_mb"], 1),
                      "memory_percent": round(memory_stats["memory_percent"], 1),
                      "available_memory_mb": round(memory_stats["available_mb"], 1),
                      "system_memory_percent": round(memory_stats["system_memory_percent"], 1)
                  },
                  "cache": {
                      "audio_cache_size": len(audio_file_cache.cache),
                      "audio_files_count": len(list(config.AUDIO_DIR.glob("*"))),
                      "cache_hit_rate": "N/A"  # Could be implemented
                  },
                  "model": {
                      "loaded": tts_model is not None,
                      "load_time": metrics.model_load_time,
                      "model_type": "KittenML/kitten-tts-nano-0.1"
                  }
              }
          
          @app.get("/voices")
          async def get_voices():
              """Get available voices with detailed information"""
              voices = get_available_voices()
              return {
                  "voices": [voice.dict() for voice in voices],
                  "total": len(voices),
                  "default": "expr-voice-2-f",
                  "recommended": {
                      "male": "expr-voice-2-m",
                      "female": "expr-voice-2-f"
                  },
                  "quality_levels": ["standard", "high"],
                  "note": "KittenTTS nano model with optimized voices"
              }
          
          @app.get("/audio/{filename}")
          async def get_audio_file(filename: str):
              """Serve audio files with enhanced headers"""
              file_path = config.AUDIO_DIR / filename
              
              if not file_path.exists():
                  raise HTTPException(status_code=404, detail="Audio file not found")
              
              # Determine media type
              extension = filename.split('.')[-1].lower()
              media_types = {
                  'wav': 'audio/wav',
                  'mp3': 'audio/mpeg',
                  'ogg': 'audio/ogg',
                  'flac': 'audio/flac'
              }
              
              media_type = media_types.get(extension, 'application/octet-stream')
              
              return FileResponse(
                  path=str(file_path),
                  media_type=media_type,
                  filename=filename,
                  headers={
                      "Content-Disposition": f"inline; filename={filename}",
                      "Cache-Control": "public, max-age=7200",  # 2 hours
                      "Accept-Ranges": "bytes",
                      "X-Content-Type-Options": "nosniff"
                  }
              )
          
          async def cleanup_file(filename: str, delay: int):
              """Clean up audio file after delay"""
              try:
                  await asyncio.sleep(delay)
                  file_path = config.AUDIO_DIR / filename
                  if file_path.exists():
                      file_path.unlink()
                      logger.info(f"üßπ Cleaned up: {filename}")
              except Exception as e:
                  logger.warning(f"Cleanup failed for {filename}: {e}")
          
          # Additional utility endpoints
          @app.post("/test-voice/{voice_name}")
          async def test_voice(voice_name: str):
              """Test a specific voice"""
              test_request = TTSRequest(
                  text=f"Hello! This is a test of the {voice_name} voice.",
                  voice=voice_name,
                  speed=1.0,
                  format="wav"
              )
              return await text_to_speech(test_request, BackgroundTasks())
          
          @app.delete("/cleanup")
          async def manual_cleanup():
              """Manual cleanup endpoint"""
              try:
                  files_before = len(list(config.AUDIO_DIR.glob("*")))
                  
                  # Clean audio files
                  for file_path in config.AUDIO_DIR.glob("*"):
                      try:
                          file_path.unlink()
                      except Exception as e:
                          logger.warning(f"Could not delete {file_path}: {e}")
                  
                  # Clear caches
                  audio_file_cache.clear()
                  cleanup_memory()
                  
                  files_after = len(list(config.AUDIO_DIR.glob("*")))
                  
                  return {
                      "message": "üßπ Manual cleanup completed",
                      "files_deleted": files_before - files_after,
                      "remaining_files": files_after,
                      "cache_cleared": True,
                      "memory_cleaned": True
                  }
              
              except Exception as e:
                  raise HTTPException(status_code=500, detail=f"Cleanup failed: {str(e)}")
          
          if __name__ == "__main__":
              uvicorn.run(
                  app,
                  host="0.0.0.0",
                  port=8000,
                  log_level="info",
                  access_log=True,
                  workers=1,  # Single worker for model consistency
                  loop="asyncio"
              )
          FASTAPI_EOF
          
          echo "‚úÖ Enhanced FastAPI server created"
          fi
          
      - name: üß™ Validate FastAPI Configuration
        run: |
          echo "üß™ Validating FastAPI configuration..."
          
          # Test import and basic validation
          python3 -c "
          import sys
          sys.path.insert(0, '.')
          
          try:
              from main import app, config, metrics
              print('‚úÖ FastAPI app imports successfully')
              
              # Test configuration
              print(f'‚úÖ Audio directory: {config.AUDIO_DIR}')
              print(f'‚úÖ Cache directory: {config.CACHE_DIR}')
              print(f'‚úÖ Max text length: {config.MAX_TEXT_LENGTH}')
              
              # Test metrics
              stats = metrics.get_stats()
              print(f'‚úÖ Metrics initialized: {len(stats)} fields')
              
              print('‚úÖ All components validated successfully')
              
          except Exception as e:
              print(f'‚ùå Validation failed: {e}')
              import traceback
              traceback.print_exc()
              sys.exit(1)
          "
          
      - name: üöÄ Start Production FastAPI Server
        run: |
          echo "üöÄ Starting production FastAPI server..."
          source monitor.sh
          
          # Show initial system stats
          show_system_stats
          
          # Start FastAPI server with enhanced logging
          echo "Starting FastAPI with production configuration..."
          nohup uvicorn main:app \
            --host 0.0.0.0 \
            --port 8000 \
            --log-level info \
            --access-log \
            --workers 1 \
            --loop asyncio \
            --http h11 \
            --ws websockets > fastapi.log 2>&1 &
          
          FASTAPI_PID=$!
          echo "FastAPI PID: $FASTAPI_PID"
          echo "$FASTAPI_PID" > fastapi.pid
          
          # Enhanced server startup verification
          echo "‚è≥ Waiting for FastAPI to initialize..."
          startup_timeout=180  # 3 minutes
          startup_time=0
          
          while [ $startup_time -lt $startup_timeout ]; do
            if curl -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ FastAPI server is responding!"
              
              # Get detailed health check
              health_response=$(curl -s http://localhost:8000/health)
              echo "Health Status: $health_response"
              break
            fi
            
            echo "‚è≥ Startup progress ($startup_time/${startup_timeout}s)..."
            
            # Show logs if startup is taking long
            if [ $startup_time -gt 60 ] && [ $((startup_time % 30)) -eq 0 ]; then
              echo "üìã Recent FastAPI logs:"
              tail -10 fastapi.log || echo "No logs yet"
            fi
            
            sleep 5
            startup_time=$((startup_time + 5))
          done
          
          # Final startup check
          if ! curl -s http://localhost:8000/health > /dev/null 2>&1; then
            echo "‚ùå FastAPI failed to start within timeout. Full logs:"
            cat fastapi.log
            show_system_stats
            exit 1
          fi
          
          echo "‚úÖ FastAPI server started successfully"
          
      - name: üåê Setup Cloudflare Tunnel with No Timeout
        run: |
          echo "üåê Setting up Cloudflare tunnel (no timeout limits)..."
          
          # Download cloudflared with caching
          CLOUDFLARED_CACHE="/tmp/cloudflared"
          if [ ! -f "$CLOUDFLARED_CACHE" ]; then
            echo "üì• Downloading cloudflared..."
            curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o "$CLOUDFLARED_CACHE"
            chmod +x "$CLOUDFLARED_CACHE"
          else
            echo "üìã Using cached cloudflared"
          fi
          
          cp "$CLOUDFLARED_CACHE" ./cloudflared
          chmod +x ./cloudflared
          
          # Enhanced tunnel startup with unlimited timeout
          echo "üöÄ Starting Cloudflare tunnel..."
          nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
          TUNNEL_PID=$!
          echo "Tunnel PID: $TUNNEL_PID"
          echo "$TUNNEL_PID" > tunnel.pid
          
          # Wait for tunnel with no time limit but with progress updates
          echo "‚è≥ Waiting for tunnel to establish (no timeout)..."
          tunnel_attempts=0
          
          while true; do
            tunnel_attempts=$((tunnel_attempts + 1))
            
            # Check for tunnel URL in logs
            if grep -q "https://.*trycloudflare.com" tunnel.log 2>/dev/null; then
              URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | head -n1)
              echo "üåê Tunnel established at: $URL"
              break
            fi
            
            # Progress reporting every 30 seconds
            if [ $((tunnel_attempts % 6)) -eq 0 ]; then
              echo "‚è≥ Tunnel attempt $tunnel_attempts (${tunnel_attempts}0s elapsed)..."
              
              # Show recent tunnel logs
              echo "üìã Recent tunnel logs:"
              tail -5 tunnel.log 2>/dev/null || echo "No tunnel logs yet"
              
              # Check if tunnel process is still running
              if ! kill -0 $TUNNEL_PID 2>/dev/null; then
                echo "‚ùå Tunnel process died, restarting..."
                nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
                TUNNEL_PID=$!
                echo "$TUNNEL_PID" > tunnel.pid
              fi
            fi
            
            sleep 5
          done
          
          # Extract and validate URL
          URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | head -n1 2>/dev/null)
          
          if [ -z "$URL" ]; then
            echo "‚ùå Failed to extract tunnel URL. Full tunnel log:"
            cat tunnel.log
            exit 1
          fi
          
          echo "üåê Tunnel URL: $URL"
          
          # Comprehensive tunnel testing
          echo "üß™ Testing tunnel connectivity..."
          test_attempts=0
          max_test_attempts=20
          
          while [ $test_attempts -lt $max_test_attempts ]; do
            if curl -s --max-time 30 "$URL/health" > /dev/null; then
              echo "‚úÖ Tunnel is working correctly!"
              
              # Test TTS endpoint
              if curl -s --max-time 10 "$URL/" > /dev/null; then
                echo "‚úÖ TTS API accessible through tunnel"
              fi
              break
            fi
            
            test_attempts=$((test_attempts + 1))
            echo "üîÑ Tunnel test attempt $test_attempts/$max_test_attempts..."
            sleep 3
          done
          
          if [ $test_attempts -eq $max_test_attempts ]; then
            echo "‚ö†Ô∏è Tunnel connectivity tests failed, but continuing..."
          fi
          
          # Enhanced webhook notification with retry
          echo "üì° Sending webhook notification..."
          webhook_payload=$(cat << EOF
          {
            "url": "$URL",
            "status": "running",
            "service": "KittenTTS Production API",
            "version": "2.0.0",
            "timestamp": "$(date -Iseconds)",
            "features": [
              "Real KittenTTS",
              "Long text support",
              "Caching enabled",
              "Robust error handling",
              "System monitoring"
            ]
          }
          EOF
          )
          
          # Try webhook with retries
          for i in {1..3}; do
            if curl -X POST "https://n8n-nightly-liyp.onrender.com/webhook/b24ea92e-9123-4cb1-8a79-9a08ae45c536" \
              -H "Content-Type: application/json" \
              -d "$webhook_payload" \
              --max-time 30; then
              echo "‚úÖ Webhook notification sent successfully"
              break
            else
              echo "‚ö†Ô∏è Webhook attempt $i failed, retrying..."
              sleep 5
            fi
          done
          
          # Save important information
          echo "üìù Saving service information..."
          cat > service_info.json << EOF
          {
            "tunnel_url": "$URL",
            "fastapi_pid": $FASTAPI_PID,
            "tunnel_pid": $TUNNEL_PID,
            "start_time": "$(date -Iseconds)",
            "endpoints": {
              "health": "$URL/health",
              "tts": "$URL/tts",
              "voices": "$URL/voices",
              "metrics": "$URL/metrics",
              "docs": "$URL/docs"
            }
          }
          EOF
          
          echo "‚úÖ Cloudflare tunnel setup completed"
          
      - name: üîÑ Production Keep-Alive with Advanced Monitoring
        run: |
          echo "üîÑ Starting production keep-alive with comprehensive monitoring..."
          source monitor.sh
          
          # Load service info
          if [ -f service_info.json ]; then
            URL=$(python3 -c "import json; print(json.load(open('service_info.json'))['tunnel_url'])")
            echo "üåê Service URL: $URL"
          else
            URL="https://unknown.trycloudflare.com"
          fi
          
          # Enhanced monitoring function
          monitor_services() {
            local cycle=$1
            echo "üîç ===== MONITORING CYCLE $cycle ====="
            
            # System statistics
            show_system_stats
            
            # Service health checks
            echo "üè• SERVICE HEALTH CHECKS:"
            
            # FastAPI health
            if curl -s --max-time 10 http://localhost:8000/health > /dev/null; then
              echo "‚úÖ FastAPI: Healthy"
              
              # Get metrics
              metrics=$(curl -s --max-time 10 http://localhost:8000/metrics 2>/dev/null || echo '{"error": "metrics unavailable"}')
              echo "üìä Metrics: $metrics"
            else
              echo "‚ùå FastAPI: Not responding"
            fi
            
            # Tunnel health
            if curl -s --max-time 10 "$URL/health" > /dev/null; then
              echo "‚úÖ Tunnel: Healthy"
            else
              echo "‚ùå Tunnel: Not responding"
            fi
            
            # Process status
            echo "‚öôÔ∏è PROCESS STATUS:"
            if [ -f fastapi.pid ] && kill -0 $(cat fastapi.pid) 2>/dev/null; then
              echo "‚úÖ FastAPI process: Running (PID: $(cat fastapi.pid))"
            else
              echo "‚ùå FastAPI process: Not running"
            fi
            
            if [ -f tunnel.pid ] && kill -0 $(cat tunnel.pid) 2>/dev/null; then
              echo "‚úÖ Tunnel process: Running (PID: $(cat tunnel.pid))"
            else
              echo "‚ùå Tunnel process: Not running"
            fi
            
            # Disk usage
            echo "üíø DISK USAGE:"
            du -sh audio_files/ 2>/dev/null || echo "Audio files: 0B"
            du -sh cache/ 2>/dev/null || echo "Cache: 0B"
            
            # Network connections
            echo "üåê NETWORK CONNECTIONS:"
            ss -tuln | grep :8000 || echo "Port 8000: Not listening"
            
            echo "üîç ===== END CYCLE $cycle ====="
            echo ""
          }
          
          # Enhanced service recovery
          recover_fastapi() {
            echo "üîß Attempting FastAPI recovery..."
            
            # Kill existing process
            if [ -f fastapi.pid ]; then
              kill $(cat fastapi.pid) 2>/dev/null || true
              sleep 5
            fi
            pkill -f uvicorn || true
            sleep 2
            
            # Clean up and restart
            cleanup_memory() {
              python3 -c "import gc; gc.collect()" 2>/dev/null || true
            }
            cleanup_memory
            
            # Restart FastAPI
            echo "üîÑ Restarting FastAPI..."
            nohup uvicorn main:app \
              --host 0.0.0.0 \
              --port 8000 \
              --log-level info \
              --access-log \
              --workers 1 > fastapi.log 2>&1 &
            
            NEW_PID=$!
            echo "$NEW_PID" > fastapi.pid
            echo "‚úÖ FastAPI restarted with PID: $NEW_PID"
            
            # Wait for recovery
            sleep 10
          }
          
          recover_tunnel() {
            echo "üîß Attempting tunnel recovery..."
            
            # Kill existing tunnel
            if [ -f tunnel.pid ]; then
              kill $(cat tunnel.pid) 2>/dev/null || true
              sleep 5
            fi
            pkill -f cloudflared || true
            sleep 2
            
            # Restart tunnel
            echo "üîÑ Restarting tunnel..."
            nohup ./cloudflared tunnel --url http://localhost:8000 --no-autoupdate > tunnel.log 2>&1 &
            NEW_TUNNEL_PID=$!
            echo "$NEW_TUNNEL_PID" > tunnel.pid
            
            # Wait for new URL
            sleep 15
            NEW_URL=$(grep -o 'https://.*trycloudflare.com' tunnel.log | tail -n1 2>/dev/null)
            if [ -n "$NEW_URL" ]; then
              URL="$NEW_URL"
              echo "‚úÖ Tunnel recovered with new URL: $URL"
              
              # Update service info
              python3 -c "
          import json
          try:
              with open('service_info.json', 'r') as f:
                  data = json.load(f)
              data['tunnel_url'] = '$NEW_URL'
              data['tunnel_pid'] = $NEW_TUNNEL_PID
              with open('service_info.json', 'w') as f:
                  json.dump(data, f, indent=2)
          except Exception as e:
              print(f'Failed to update service info: {e}')
              "
            else
              echo "‚ùå Tunnel recovery failed"
            fi
          }
          
          # Main monitoring loop - UNLIMITED TIME
          echo "üîÑ Starting unlimited monitoring loop..."
          cycle=0
          last_health_check=0
          consecutive_failures=0
          max_consecutive_failures=5
          
          while true; do
            cycle=$((cycle + 1))
            current_time=$(date +%s)
            
            # Show monitoring every 2 minutes
            if [ $((current_time - last_health_check)) -ge 120 ]; then
              monitor_services $cycle
              last_health_check=$current_time
            fi
            
            # Health checks and recovery every 30 seconds
            fastapi_healthy=false
            tunnel_healthy=false
            
            # Check FastAPI
            if curl -s --max-time 15 http://localhost:8000/health > /dev/null; then
              fastapi_healthy=true
              consecutive_failures=0
            else
              echo "‚ö†Ô∏è FastAPI health check failed"
              consecutive_failures=$((consecutive_failures + 1))
            fi
            
            # Check tunnel
            if curl -s --max-time 15 "$URL/health" > /dev/null; then
              tunnel_healthy=true
            else
              echo "‚ö†Ô∏è Tunnel health check failed"
            fi
            
            # Recovery logic
            if [ "$fastapi_healthy" = false ] && [ $consecutive_failures -ge 3 ]; then
              echo "üö® FastAPI requires recovery (failures: $consecutive_failures)"
              recover_fastapi
              consecutive_failures=0
            fi
            
            if [ "$tunnel_healthy" = false ] && [ "$fastapi_healthy" = true ]; then
              echo "üö® Tunnel requires recovery"
              recover_tunnel
            fi
            
            # Memory management
            if [ $((cycle % 50)) -eq 0 ]; then  # Every ~25 minutes
              echo "üßπ Performing periodic maintenance..."
              
              # Force garbage collection via API
              curl -s --max-time 10 http://localhost:8000/cleanup > /dev/null || true
              
              # System cleanup
              python3 -c "import gc; gc.collect()" 2>/dev/null || true
              
              echo "‚úÖ Maintenance completed"
            fi
            
            # Status update every 10 minutes
            if [ $((cycle % 120)) -eq 0 ]; then
              echo "üì° Status update (cycle $cycle):"
              echo "  üåê URL: $URL"
              echo "  ‚è∞ Uptime: $((cycle * 30 / 60)) minutes"
              echo "  ‚úÖ FastAPI: $fastapi_healthy"
              echo "  ‚úÖ Tunnel: $tunnel_healthy"
              echo "  üîÑ Failures: $consecutive_failures"
              
              # Test TTS functionality
              echo "üß™ Testing TTS functionality..."
              test_response=$(curl -s --max-time 30 -X POST "$URL/tts" \
                -H "Content-Type: application/json" \
                -d '{"text": "Hello, this is a test message", "voice": "expr-voice-2-f"}' 2>/dev/null)
              
              if echo "$test_response" | grep -q '"status":"success"'; then
                echo "‚úÖ TTS test successful"
              else
                echo "‚ö†Ô∏è TTS test failed: $test_response"
              fi
            fi
            
            # Progressive sleep intervals to reduce resource usage
            if [ $cycle -lt 120 ]; then
              sleep 30  # First hour: check every 30 seconds
            elif [ $cycle -lt 720 ]; then
              sleep 60  # Next 10 hours: check every minute
            else
              sleep 120 # After that: check every 2 minutes
            fi
          done
          
      - name: üõë Graceful Shutdown and Cleanup
        if: always()
        run: |
          echo "üõë Performing graceful shutdown..."
          
          # Show final statistics
          source monitor.sh
          echo "üìä FINAL SYSTEM STATISTICS:"
          show_system_stats
          
          # Get final metrics from API
          echo "üìà FINAL API METRICS:"
          curl -s --max-time 10 http://localhost:8000/metrics || echo "Metrics unavailable"
          
          # Graceful shutdown of services
          echo "üîÑ Stopping services gracefully..."
          
          # Signal FastAPI to shutdown gracefully
          if [ -f fastapi.pid ] && kill -0 $(cat fastapi.pid) 2>/dev/null; then
            echo "üì§ Sending SIGTERM to FastAPI..."
            kill -TERM $(cat fastapi.pid) 2>/dev/null || true
            sleep 10
            
            # Force kill if still running
            if kill -0 $(cat fastapi.pid) 2>/dev/null; then
              echo "üì§ Force killing FastAPI..."
              kill -KILL $(cat fastapi.pid) 2>/dev/null || true
            fi
          fi
          
          # Stop tunnel
          if [ -f tunnel.pid ] && kill -0 $(cat tunnel.pid) 2>/dev/null; then
            echo "üì§ Stopping tunnel..."
            kill $(cat tunnel.pid) 2>/dev/null || true
          fi
          
          # Cleanup processes
          pkill -f uvicorn || true
          pkill -f cloudflared || true
          
          # Show final logs
          echo "üìã ===== FINAL LOGS ====="
          echo "FastAPI logs (last 50 lines):"
          tail -50 fastapi.log 2>/dev/null || echo "No FastAPI logs"
          echo ""
          echo "Tunnel logs (last 20 lines):"
          tail -20 tunnel.log 2>/dev/null || echo "No tunnel logs"
          echo ""
          
          # Archive logs and important files
          echo "üì¶ Archiving session data..."
          mkdir -p session_archive
          cp fastapi.log session_archive/ 2>/dev/null || true
          cp tunnel.log session_archive/ 2>/dev/null || true
          cp service_info.json session_archive/ 2>/dev/null || true
          cp kittentts.log session_archive/ 2>/dev/null || true
          
          # Final status
          echo "‚úÖ Shutdown completed successfully"
          echo "üìä Session archived in session_archive/"
